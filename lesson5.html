<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Tecnologias web</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css" id="theme">
		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">
		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>
	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Sistemas y Tecnologías Web</h1>
					<h3>Javascript</h3>
					<p>
						<small>por <a href="https://github.com/denn1s">Dennis Aldana</a></small>
					</p>
				</section>
				<section>
					<h1>You don't know javascript.</h1>
				</section>
				<section>
					<h2>Hoy</h2>
					<ol>
						
					</ol>
				</section>

				<section>
						<section>
							<h1>Intro</h1>
						</section>
						<section>
							<h2>Javascript console</h2>
							<ul>
								<li>window</li>
								<li>document</li>
								<li>console</li>
								<li>alert, prompt, confirm</li>
							</ul>
						</section>
						<section>
<ul style="font-size: 32px">
<li>Assignment: =</li>
<li>Math: + (addition), - (subtraction), * (multiplication), and / (division)</li>
<li>Compound Assignment: +=, -=, *=, and /=</li>
<li>Increment/Decrement: ++ (increment), -- (decrement)</li>
<li>Object Property Access: .</li>
<li>Equality: == (loose-equals), === (strict-equals), != (loose not-equals), !== (strict not-equals)</li>
<li>Comparison: < (less than), > (greater than), <= (less than or loose-equals), >= (greater than or loose-equals), as in a <= b.</li>
<li>Logical: && (and), || (or), as in a || b that selects either a or b.</li>
</ul>
						</section>
						<section>
							<a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">
								https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators
							</a>
						</section>
						<section>
							<h2>Comentarios</h2>
							<ul>
								<li> // en linea </li>
								<li> /* de bloque */ </li>
							</ul>
						</section>
						<section>
							<h2>Variables</h2>
							<ul>
								<li>Las variables deben ser declaradas</li>
								<li>Javascript usa <em>dynamic typing</em></li>
							</ul>
						</section>
						<section>
							<p>
								El propósito de las variables es mantener el <em>estado</em> actual del programa.
							</p>
						</section>
						<section>
								<h2>Tipos de variables</h2>
								<pre><code class="hljs" data-trim contenteditable>
										var a;
										typeof a;				// "undefined"

										a = "hello world";
										typeof a;				// "string"

										a = 42;
										typeof a;				// "number"

										a = true;
										typeof a;				// "boolean"

										a = null;
										typeof a;				// bug

										a = undefined;
										typeof a;				// "undefined"

										a = { b: "c" };
										typeof a;				// "object"
								</code></pre>
							</section>
						<section>
								<h2>objetos</h2>
								<pre><code class="hljs" data-trim contenteditable>
										var obj = {
											a: "hello world",
											b: 42,
											c: true
										}

										obj.a		// "hello world"
										obj.b		// 42
										obj.c		// true

										obj["a"]	// "hello world"
										obj["b"]	// 42
										obj["c"]	// true
								</code></pre>
							</section>

						<section>
								<h2>array?</h2>
								<pre><code class="hljs" data-trim contenteditable>
									var arr = [
										"hello world",
										42,
										true
									]
									typeof arr		// "object"

									arr[0]			// "hello world"
									arr[1]			// 42
									arr[2]			// true
									arr.length		// 3

								</code></pre>
							</section>
							<section>
								<h2>Object deconstruction</h2>
								<pre><code class="hljs" data-trim contenteditable>
									var arr = [
										"hello world",
										42,
										true
									]
									var [ a, b, c ] = arr

									a			// "hello world"
									b			// 42
									c			// true
								</code></pre>
							</section>

							<section>
									<h2>Object deconstruction (cont.)</h2>
									<pre><code class="hljs" data-trim contenteditable>
										var obj = {
											a: "hello world",
											b: 42,
											c: true
										}

										var { a, b, c } = obj
									</code></pre>
								</section>

						<section>
							<h2>Block</h2>
							<ul>
								<li> { } </li>
								<li> Tipicamente estan pegados a control de flujo </li>
							</ul>
						</section>
						<section>
							<h2>Function</h2>
							<ul>
								<li> function a { } </li>
								<li> Puede ser llamada despues </li>
								<li> Puede ser anónima </li>
							</ul>
						</section>
						<section>
							<p>Una función puede usarse como cualquier objeto</p>
							<pre><code class="hljs" data-trim contenteditable>
							function bar() {
								console.log('bar')
							}

							bar.a = 100

							setTimeout(bar, 3000)
							</code></pre>
						</section>
				</section>
				<section>
					<section>
						<h1>Scopes</h1>
					</section>
					<section>
						<p>
							Un scope es un set de reglas que determina como y donde una variable puede ser encontrada.
							<br /><br />

							Hay dos maneras de acceder a una variable, para asignar (LHS) y para leer (RHS).
							<br /><br />

							Primero se revisa el scope que se esta ejecutando, despues los de arriba.
						</p>
					</section>
					<section>
							<pre><code class="hljs" data-trim contenteditable>
									function foo(a) {
										console.log(a)
									}

									foo(2)
							</code></pre>
						</section>
						<section>
							<pre><code class="hljs" data-trim contenteditable>
									function foo(a) {
										console.log(a + b)
									}

									var b = 3
									foo(2)
							</code></pre>
						</section>
						<section>
							<pre><code class="hljs" data-trim contenteditable>
									function foo(a) {
										console.log( a + b )
										var b = 300
									}

									var b = 3
									var a = 100

									foo( 2 )
							</code></pre>
						</section>
						<section>
							<h1>???</h1>
						</section>
						<section>
								<pre><code class="hljs" data-trim contenteditable>
										function foo(a) {
											var b
											console.log( a + b )
											b = 300
										}
	
										var b = 3
										var a = 100
	
										foo( 2 )
								</code></pre>
							</section>
							<section>
							<pre><code class="hljs" data-trim contenteditable>
									function bar(a) {
										i = 100
										console.log( a + i )
									}
									
									for (var i=0; i<10; i++) {
										bar( i * 2 )
									}
							</code></pre>
						</section>
							<section>
								<h1>let / const</h1>
								<ul>
									<li>Introducido en ES6</li>
									<li>Pega la variable al scope más cercano</li>
								</ul>
						</section>
						<section>
								<pre><code class="hljs" data-trim contenteditable>
								{
									console.log(a)
									var a = 5
								}
								console.log(a)
								</code></pre>
						</section>
						<section>
								<pre><code class="hljs" data-trim contenteditable>
								{
									let a = 5
									console.log(a)
								}
								let a = 10
								console.log(a)
								</code></pre>
						</section>
						<section>
							<h2>Son las funciones más como var o como let?</h2>
						</section>
						<section>
								<pre><code class="hljs" data-trim contenteditable>
										foo()

										var foo

										function foo() {
											console.log(1)
										}

										foo = function() {
											console.log(2)
										}
								</code></pre>
						</section>
						<section>
								<pre><code class="hljs" data-trim contenteditable>
										function foo() {
											console.log(1)
										}

										foo()

										foo = function() {
											console.log(2)
										}
								</code></pre>
						</section>
						<section>
								<pre><code class="hljs" data-trim contenteditable>
										function foo() {
											console.log(1)
										}

										foo()

										function foo() {
											console.log(2)
										}
								</code></pre>
						</section>
						<section>
								<pre><code class="hljs" data-trim contenteditable>
									foo()

									function foo() {
										console.log(1)
									}

									var foo = function() {
										console.log(2)
									}

									function foo() {
										console.log(3)
									}
								</code></pre>
						</section>
				</section>
				<section>
					<section>
						<h1>this</h1>
					</section>
					<section>
						<p>
							"this" es lo que llamamos un runtime binding, es un contexto que se crea cuando se ejecuta el scope, no cuando se escribe.
						</p>
					</section>
					<section>
							<pre><code class="hljs" data-trim contenteditable>
									function foo(num) {
										console.log( "foo: " + num )
										this.count++
									}

									foo.count = 0

									for (let i=0; i<10; i++) {
										foo( i )
									}

									console.log("Total executions:", foo.count)
							</code></pre>
					</section>
					<section>
							<pre><code class="hljs" data-trim contenteditable>
									function foo() {
										console.log(this.a)
									}

									var a = 2

									foo()
							</code></pre>
					</section>
					<section>
							<pre><code class="hljs" data-trim contenteditable>
									(function() {
										function foo() {
											console.log(this.a)
										}

										let a = 2

										foo()
									})()
							</code></pre>
					</section>
					<section>
							<pre><code class="hljs" data-trim contenteditable>
									function foo() {
										console.log(this.a)
									}

									let obj = {
										a: 2,
										foo: foo
									}

									obj.foo()
							</code></pre>
					</section>
					<section>
							<pre><code class="hljs" data-trim contenteditable>
									function foo() {
										console.log(this.a)
									}

									let obj = {
										a: 2,
										foo: foo
									}

									let obj2 = {
										a: 100,
										foo: foo
									}

									obj.foo()
									obj2.foo()
							</code></pre>
					</section>
					<section>
							<pre><code class="hljs" data-trim contenteditable>
									function foo() {
										console.log(this.a)
									}

									let obj = {
										a: 2,
										foo: foo
									}

									let a = "global scoped a"

									setTimeout(obj.foo, 1000)
							</code></pre>
					</section>
					<section>
							<h1>call</h1>
							<pre><code class="hljs" data-trim contenteditable>
									function foo() {
										console.log(this.a)
									}

									let obj = {
										a: 2
									}

									let a = "global scoped a"

									foo.call(obj)
							</code></pre>
					</section>
					<section>
							<h1>bind</h1>
							<pre><code class="hljs" data-trim contenteditable>
									function foo() {
										console.log(this.a)
									}

									let obj = {
										a: 2
									}

									let bindedFoo = foo.bind(obj)

									let a = "global scoped a"

									setTimeout(bindedFoo, 1000)
							</code></pre>
					</section>
					<section>
							<h1>bind (cont.)</h1>
							<pre><code class="hljs" data-trim contenteditable>
									function foo(param1, param2) {
										console.log(this.a, param1, param2)
									}

									let obj = {
										a: 2
									}

									let bindedFoo = foo.bind(obj, 'hello', 'world')

									let a = "global scoped a"

									setTimeout(bindedFoo, 1000)
							</code></pre>
					</section>
				</section>
				
				<section>
					<section>
						<h1>FUNCTIONS</h1>
					</section>
					<section>
						<p>Las funciones en javascript pueden ser tratadas como objetos. A este tipo de funciones se les llama first-class funcions</p>
						<ul>
							<li>Las funciones pueden ser asignadas a variables</li>
							<li>Las funciones pueden ser retornadas por otras funciones</li>
							<li>Las funciones pueden ser pasadas como argumentos a otras funciones</li>
						</ul>
					</section>
					<section>
						<p>Las funciones pueden ser asignadas a variables</p>
						<pre><code class="hljs" data-trim contenteditable>
							const sayHello = () => {
								return 'Hello'
							} // es posible escribir esto en una línea

							console.log(sayHello())
						</code></pre>
					</section>
					<section>
						<p>Las funciones pueden ser retornadas por otras funciones</p>
						<pre><code class="hljs" data-trim contenteditable>
							const greeterMaker = greeting => {
								return person => {
									return greeting + ' ' + person
								}
							}
							const sayHelloToPerson = greeterMaker('Hello')
							const sayHowdyToPerson = greeterMaker('Howdy')

							console.log(sayHelloToPerson('Joanne'))
							console.log(sayHowdyToPerson('Joanne'))
						</code></pre>
					</section>
					<section>
						<p>Las funciones pueden ser pasadas como parametro a otras funciones</p>
						<pre><code class="hljs" data-trim contenteditable>
							const sayHelloToPerson = (greeter, person) => {
								return greeter() + ' ' + person;
							};
							
							console.log(sayHelloToPerson(sayHello, 'John'));
						</code></pre>
					</section>
					<section>
						<h2>Ejemplo</h2>
						<pre><code class="hljs" data-trim contenteditable>
							const usernameLongEnough = obj => {
								return obj.username.length >= 5
							}
							
							const passwordsMatch = obj => {
								return obj.password === obj.confirmPassword
							}
							
							const objectIsValid = (obj, ...funcs) => {
								for (let i = 0; i < funcs.length; i++) {
									if (funcs[i](obj) === false) {
										return false
									}
								}
							
								return true
							}
							
							const obj1 = {
								username: 'abc123',
								password: 'foobar',
								confirmPassword: 'foobar',
							}
							
							const obj1Valid = objectIsValid(obj1, usernameLongEnough, passwordsMatch)
							console.log(obj1Valid)

							const obj2 = {
								username: 'joe555',
								password: 'foobar',
								confirmPassword: 'oops',
							}
							
							const obj2Valid = objectIsValid(obj2, usernameLongEnough, passwordsMatch)
							console.log(obj2Valid)
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h1>map, filter y reduce</h1>
					</section>
					<section>
							<p>
								<strong>map</strong> crea un nuevo array de elementos con los resultados de llamar a una función para cada elemento del array
							</p>
							<pre><code class="hljs" data-trim contenteditable>
								const numbers = [2, 4, 8, 10]
								const halves = numbers.map(x => x / 2)
							</code></pre>
					</section>
					<section>
						<ul>
							<li>map se usa cuando tienen un array y quieren hacer algo con cada elemento del array</li>
							<li>el array resultante es siempre del mismo tamaño del array original</li>
						</ul>
					</section>
					<section>
							<p>
								<strong>filter</strong> crea un nuevo array con los elementos que pasen el test en la función que recibe como parámetro 
							</p>
							<pre><code class="hljs" data-trim contenteditable>
									const words = ["spray", "limit", "elite", "exuberant", "destruction", "present"]

									const longWords = words.filter(word => word.length > 6)
							</code></pre>
					</section>
					<section>
							<ul>
								<li>filter se usa cuando quieren reducir el número de elementos del array</li>
								<li>el array resultante es más pequeño que el array original, o igual</li>
							</ul>
					</section>
					<section>
							<p>
								<strong>reduce</strong> aplica una función con un acumulador y cada elemento del array.
							</p>
							<pre><code class="hljs" data-trim contenteditable>
									const total = [0, 1, 2, 3].reduce((sum, value) => sum + value, 1)
							</code></pre>
					</section>
					<section>
						<ul>
							<li>reduce se usa cuando quieren <em>reducir</em> el resultado de un array a un solo valor</li>
							<li>el resultado es siempre un solo valor</li>
						</ul>
					</section>
				</section>

				<section>
						<section>
							<h1>callbacks, promises y async</h1>
						</section>
						<section>
							<p>
								Asincronía se refiere a la ocurrencia de eventos fuera del flujo principal del programa.
								<br />
								Esto normalmente se refiere a threads,
								sin embargo, este no es el caso para javascript, pues es single threaded por diseño.
								<br />
								> <em>“asynchronous non-blocking I/O model”</em>
							</p>
						</section>
						<section>
							<h1>Callbacks</h1>
							<p>
								Es un patrón de diseño en el que una función se llama cuando la operación termina
							</p>
							<pre><code class="hljs" data-trim contenteditable>
									document.addEventListener("click", function() {
										document.getElementById("demo").innerHTML = "Hello World"
									})
							</code></pre>
						</section>
						<section>
							<h1>Callback hell</h1>
							<pre><code class="hljs" data-trim contenteditable>
									const request = require(‘request’)
									let result
									request('http://www.somepage.com', function (error, response, body) {
											if (error) {
													result = error
											}
											else {
													result = body
											}
									})
									console.log(result)
								</code></pre>
						</section>
						<section>
							<h1>Callback hell</h1>
							<pre><code class="hljs" data-trim contenteditable>
									request('http://www.somepage.com', function (firstError, firstResponse, firstBody) {
										if(firstError){
												// Handle error.
										}
										else {
												request(`http://www.somepage.com/${firstBody.someValue}`, function (secondError, secondResponse, secondBody) {
														if(secondError){
																// Handle error.
														}
														else {
																// Use secondBody for something
														}
												})
										}
								})
								</code></pre>
						</section>
						<section>
								<h1>Callback hell</h1>
								<pre><code class="hljs" data-trim contenteditable>
										request('http://www.somepage.com', function (firstError, firstResponse, firstBody) {
											if(firstError){
													// Handle error.
											}
											else {
													request(`http://www.somepage.com/${firstBody.someValue}`, function (secondError, secondResponse, secondBody) {
															if(secondError){
																	// Handle error.
															}
															else {
																request(`http://www.somepage.com/${secondBody.someValue}`, function (thirdError, thirdResponse, thirdBody) {
																	if (thirdError) {
																		// Handle error.
																	}
																	else {
																		// ...
																	}
																}
															}
													})
											}
									})
									</code></pre>
							</section>
							<section>
								<img src="https://miro.medium.com/max/2000/1*tR_X2VN31nM7GX_SEJynew.png" />
							</section>
							<section>
								<img src="https://s3.amazonaws.com/com.twilio.prod.twilio-docs/original_images/31orCejQRkSvmchYeZC2GKswNtst-d_xEoSPoP3X-bAm9RRe8hxz59vVZrrRm78VvJgVbuUo5R.png" />
							</section>
							<section>
									<h1>Promesas</h1>
									<p>
										Una promesa es un objeto que cubre una función asincrona y notifica cuando termina
									</p>
									<pre><code class="hljs" data-trim contenteditable>
											fetch('http://ifconfig.co')
												.then(function(result){
														// Do something with the result
												})
												.catch(function(error){
														// Handle error
												})
									</code></pre>
								</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
										function fetch(someValue){
											return new Promise(function(resolve, reject) {
													getData(someValue, function(error, result) {
															if(error){
																	reject(error)
															}
															else{
																	resolve(result)
															}
													})
											})
									}
								</code></pre>
							</section>
							<section>
								<img src="https://miro.medium.com/max/2000/1*EmAEKcfZrgtNZZU9fWRcCA.png" />
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
										const axios = require(‘axios’);
										axios.get(‘http://www.somepage.com')
										.then(function (response) {
												return axios.get(`http://www.somepage.com/${response.someValue}`)
										})
										.then(function response {
												// Handle response
										})
										.catch(function (error) {
												// Handle error.
										})
								</code></pre>
							</section>
							<section>
								<h1>Promise hell</h1>
								<img src="https://miro.medium.com/max/2000/1*xf9HV-PYyu-dXzB1hp5New.png" />
							</section>
							<section>
								<h1>async y await</h1>
								<p>
									async se usa para declarar que una función va a realizar operaciones asincronas <br />
									await se usa para indicar que queremos "esperar" el resultado 
								</p>
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
									async function getSomeAsyncData(value){
										const result = await fetchTheData(someUrl, value)
										return result
									}
								</code></pre>
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
									async function fetchTheFirstData(value) {
											return await get("someUrl", value)
									}
									async function fetchTheSecondData(value) {
											return await getFromDatabase(value)
									}
									async function getSomeData(value) {
											const firstResult = await fetchTheFirstData(value)
											const result = await fetchTheSecondData(firstResult.someValue)
									}
								</code></pre>
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
										function scaryClown() {
											return new Promise(resolve => {
												setTimeout(() => {
													resolve('(❁○ ワ ○)')
												}, 2000)
											})
										}
										
										async function msg() {
											const msg = await scaryClown()
											console.log('Message:', msg)
										}
										
										msg()
								</code></pre>
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
										function who() {
											return new Promise(resolve => {
												setTimeout(() => {
													resolve('(❁○ ワ ○) ')
												}, 200)
											});
										}
										
										function what() {
											return new Promise(resolve => {
												setTimeout(() => {
													resolve('lurks')
												}, 300)
											})
										}
										
										function where() {
											return new Promise(resolve => {
												setTimeout(() => {
													resolve('in the shadows')
												}, 500)
											})
										}
										
										async function msg() {
											const a = await who()
											const b = await what()
											const c = await where()
										
											console.log(`${ a } ${ b } ${ c }`)
										}
										
										msg()
								</code></pre>
							</section>
							<section>
								<h1>Generators</h1>
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
									function * spartaGenerator() {
										yield 'This';
										yield 'is';
										yield 'sparta.'
									}

									const spartaObject = spartaGenerator()

									spartaObject.next()
								</code></pre>
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
										function fetchJson(url) {
											return fetch(url)
											.then(request => request.text())
											.then(text => {
													return JSON.parse(text)
											})
									}
								</code></pre>
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
										const fetchJson = function *(url) {
											let request = yield fetch(url)
											let text = yield request.json()
											return JSON.parse(text)
										}
								</code></pre>
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
										function * naturalNumbers() {
											let num = 1
											while (true) {
												yield num
												num = num + 1
											}
										}
										const numbers = naturalNumbers()
								</code></pre>
							</section>
							<section>
								<pre><code class="hljs" data-trim contenteditable>
										function * fibonacci(seed1, seed2) {
											while (true) {
												yield (() => {
													seed2 = seed2 + seed1
													seed1 = seed2 - seed1
													return seed2
												})()
											}
										}
										
										const fib = fibonacci(0, 1)
										fib.next()
								</code></pre>
							</section>
				</section>

				<section>
					<h1>Recomendaciones</h1>
					<a href="https://mostly-adequate.gitbooks.io/mostly-adequate-guide/content/">
						https://mostly-adequate.gitbooks.io/mostly-adequate-guide/content/
					</a>
				</section>
				
				<section style="text-align: left;">
					<h1>Fin</h1>
					<p>
						- Proxima clase: react <br />
						- &iquest;Preguntas?
					</p>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
